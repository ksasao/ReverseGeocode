<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœ¬ä½æ‰€æ¤œç´¢ãƒãƒƒãƒ—</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            font-family: 'Hiragino Kaku Gothic Pro', 'ãƒ’ãƒ©ã‚®ãƒè§’ã‚´ Pro W3', Meiryo, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        /* ç¾åœ¨ä½ç½®è¡¨ç¤ºãƒ‘ãƒãƒ« */
        .location-panel {
            position: fixed;
            top: 10px;
            left: 70px;
            width: calc(100vw - 450px);
            max-width: 500px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            max-height: 200px;
            overflow: hidden;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        .location-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .location-header h3 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }
        
        .location-controls {
            display: flex;
            gap: 8px;
        }
        
        .location-toggle {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        
        .location-toggle:hover {
            background: #45a049;
        }
        
        .location-toggle.disabled {
            background: #999;
            color: white;
        }
        
        .location-toggle.disabled:hover {
            background: #888;
        }
        
        .prediction-toggle {
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }
        
        .prediction-toggle:hover {
            background: #1976D2;
        }
        
        .prediction-toggle.disabled {
            background: #999;
        }
        
        .current-address {
            font-size: 14px;
            line-height: 1.5;
        }
        
        .current-address .address {
            font-weight: bold;
            color: #2c5aa0;
            margin-bottom: 3px;
        }
        
        .current-address .kana {
            color: #666;
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .current-address .coords {
            color: #999;
            font-size: 11px;
        }
        
        .current-address .prediction-info {
            color: #2196F3;
            font-size: 11px;
            font-style: italic;
            margin-top: 3px;
        }
        
        .location-status {
            color: #666;
            font-size: 12px;
            font-style: italic;
        }
        
        .location-error {
            color: #d32f2f;
            font-size: 12px;
        }
        
        .info-panel {
            position: fixed;
            top: 10px;
            right: 5px;
            z-index: 1000;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            width: 280px;
            max-width: calc(100vw - 25px);
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            transition: all 0.3s ease;
        }
        
        .info-panel.collapsed {
            width: 30px;
            min-width: 30px;
            min-height: 30px;
        }
        
        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .info-panel-header h3 {
            margin: 0;
            color: #333;
            font-size: 18px;
        }
        
        .collapse-toggle {
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .collapse-toggle:hover {
            background: #e0e0e0;
        }
        
        .info-panel-content {
            transition: all 0.3s ease;
        }
        
        .info-panel.collapsed .info-panel-content {
            display: none;
        }
        
        .info-panel.collapsed h3 {
            display: none;
        }
        
        .info-panel p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        .loading .progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
        
        .popup-content {
            font-size: 14px;
            line-height: 1.5;
        }
        
        .popup-content .address {
            font-weight: bold;
            color: #2c5aa0;
            margin-bottom: 5px;
        }
        
        .popup-content .kana {
            color: #666;
            font-size: 12px;
        }
        
        .popup-content .coords {
            color: #999;
            font-size: 11px;
            margin-top: 5px;
            border-top: 1px solid #eee;
            padding-top: 5px;
        }
        
        .search-radius {
            color: #888;
            font-size: 11px;
            font-style: italic;
        }
        
        .performance-info {
            background: #f0f8ff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 768px) {
            .location-panel {
                position: fixed;
                top: 10px;
                left: 70px;
                width: calc(100vw - 110px);
                max-width: none;
            }
            
            .info-panel {
                position: fixed;
                top: 150px;
                width: calc(100vw - 45px);
                max-width: none;
                left: 12px;
                right: 12px;
            }
            
            .info-panel.collapsed {
                top: 150px;
                right: 12px;
                width: 30px;
                left: auto;
            }
            
            body.info-collapsed .location-panel {
                width: calc(100vw - 110px);
                right: 12px;
            }
            
            #map {
                padding-top: 450px;
                height: calc(100vh - 450px);
            }
            
            body.info-collapsed #map {
                padding-top: 170px;
                height: calc(100vh - 170px);
            }
        }
        
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div>ä½æ‰€ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        <div class="progress" id="progress"></div>
    </div>
    
    <!-- ç¾åœ¨ä½ç½®è¡¨ç¤ºãƒ‘ãƒãƒ« -->
    <div class="location-panel" id="locationPanel" style="display: none;">
        <div class="location-header">
            <h3>ğŸ“ ç¾åœ¨ä½ç½®</h3>
            <div class="location-controls">
                <button class="prediction-toggle disabled" id="predictionToggle" onclick="togglePrediction()">
                    äºˆæ¸¬ OFF
                </button>
                <button class="location-toggle disabled" id="locationToggle" onclick="toggleLocationTracking()">
                    ä½ç½®è¿½å¾“ OFF
                </button>
            </div>
        </div>
        <div id="locationContent">
            <div class="location-status">ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­...</div>
        </div>
    </div>
    
    <div class="info-panel" id="infoPanel">
        <div class="info-panel-header">
            <h3>ğŸ—¾ æ—¥æœ¬ä½æ‰€æ¤œç´¢ãƒãƒƒãƒ—</h3>
            <button class="collapse-toggle" onclick="toggleInfoPanel()" title="ãƒ‘ãƒãƒ«ã‚’æŠ˜ã‚ŠãŸãŸã‚€">âˆ’</button>
        </div>
        <div class="info-panel-content">
            <p>åœ°å›³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®å ´æ‰€ã®ä½æ‰€ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
            <p>ä½ç½®è¿½å¾“ã‚’ONã«ã™ã‚‹ã¨ã€ç¾åœ¨ä½ç½®ã®ä½æ‰€ã‚’å¸¸æ™‚è¡¨ç¤ºã—ã¾ã™ã€‚</p>
            <p>äºˆæ¸¬æ©Ÿèƒ½ã‚’ONã«ã™ã‚‹ã¨ã€éå»ã®ç§»å‹•å±¥æ­´ã‹ã‚‰ä½ç½®ã‚’äºˆæ¸¬ã—ã¦æ»‘ã‚‰ã‹ã«æ›´æ–°ã•ã‚Œã¾ã™ã€‚</p>
            <p>ãƒ‡ãƒ¼ã‚¿ã¯ãƒ‡ã‚¸ã‚¿ãƒ«åºã®ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚«ã‚¿ãƒ­ã‚°ã®ãƒ‡ãƒ¼ã‚¿ã‚’åŠ å·¥ã—ã¦åˆ©ç”¨ã—ã¦ã„ã¾ã™[<a href="https://github.com/ksasao/ReverseGeocode/">è©³ç´°</a>]</p>
            <p class="search-radius">â€» ã‚¯ãƒªãƒƒã‚¯åœ°ç‚¹ã‹ã‚‰ 5km ä»¥å†…ã®æœ€å¯„ã‚Šä½æ‰€ã‚’æ¤œç´¢</p>
            <div class="performance-info" id="performance" style="display: none;">
                <div>ãƒ‡ãƒ¼ã‚¿ä»¶æ•°: <span id="dataCount">-</span>ä»¶</div>
                <div>kdæœ¨æ§‹ç¯‰æ™‚é–“: <span id="buildTime">-</span>ms</div>
                <div>æ¤œç´¢æ™‚é–“: <span id="searchTime">-</span>ms</div>
                <div>äºˆæ¸¬æ›´æ–°é »åº¦: <span id="predictionRate">-</span>Hz</div>
            </div>
        </div>
    </div>
    
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let addressData = [];
        let kdTree = null;
        let locationTracking = false;
        let currentLocationMarker = null;
        let watchId = null;
        let followingLocation = false;
        
        // ä½ç½®äºˆæ¸¬æ©Ÿèƒ½ã®å¤‰æ•°
        let predictionEnabled = false;
        let locationHistory = [];
        let predictionTimer = null;
        let lastKnownPosition = null;
        let lastUpdateTime = null;
        let currentPredictedPosition = null;
        
        // äºˆæ¸¬ã®è¨­å®š
        const PREDICTION_HISTORY_SIZE = 5; // å±¥æ­´ä¿æŒæ•°
        const PREDICTION_UPDATE_INTERVAL = 100; // 100ms = 10Hz
        const MAX_PREDICTION_TIME = 5000; // æœ€å¤§5ç§’é–“äºˆæ¸¬
        const MIN_SPEED_THRESHOLD = 0.5; // æœ€ä½ç§»å‹•é€Ÿåº¦ (m/s)
        
        // kdæœ¨ã®ãƒãƒ¼ãƒ‰
        class KDNode {
            constructor(point, axis, left = null, right = null) {
                this.point = point;
                this.axis = axis; // 0: ç·¯åº¦, 1: çµŒåº¦
                this.left = left;
                this.right = right;
            }
        }
        
        // kdæœ¨ã®å®Ÿè£…
        class KDTree {
            constructor(points) {
                this.root = this.buildTree(points, 0);
            }
            
            buildTree(points, depth) {
                if (points.length === 0) return null;
                
                const axis = depth % 2; // 0: lat, 1: lon
                
                // ç¾åœ¨ã®è»¸ã§ã‚½ãƒ¼ãƒˆ
                points.sort((a, b) => {
                    return axis === 0 ? a.lat - b.lat : a.lon - b.lon;
                });
                
                const median = Math.floor(points.length / 2);
                const node = new KDNode(points[median], axis);
                
                node.left = this.buildTree(points.slice(0, median), depth + 1);
                node.right = this.buildTree(points.slice(median + 1), depth + 1);
                
                return node;
            }
            
            // æœ€è¿‘å‚æ¤œç´¢
            findNearest(targetLat, targetLon, maxDistance = 5000) {
                let best = null;
                let bestDistance = Infinity;
                
                const search = (node, depth = 0) => {
                    if (!node) return;
                    
                    // ç¾åœ¨ã®ãƒãƒ¼ãƒ‰ã¨ã®è·é›¢ã‚’è¨ˆç®—
                    const distance = this.calculateDistance(targetLat, targetLon, node.point.lat, node.point.lon);
                    
                    if (distance <= maxDistance && distance < bestDistance) {
                        bestDistance = distance;
                        best = { ...node.point, distance };
                    }
                    
                    const axis = depth % 2;
                    const targetValue = axis === 0 ? targetLat : targetLon;
                    const nodeValue = axis === 0 ? node.point.lat : node.point.lon;
                    
                    // ã©ã¡ã‚‰ã®å­ã‚’å…ˆã«æ¢ç´¢ã™ã‚‹ã‹æ±ºã‚ã‚‹
                    const primary = targetValue < nodeValue ? node.left : node.right;
                    const secondary = targetValue < nodeValue ? node.right : node.left;
                    
                    // ä¸»è¦å´ã‚’æ¢ç´¢
                    search(primary, depth + 1);
                    
                    // åˆ†å‰²ç·šã¨ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆç°¡å˜ãªè¿‘ä¼¼ï¼‰
                    const splitDistance = Math.abs(targetValue - nodeValue) * 111000; // å¤§ã¾ã‹ãªåº¦â†’ãƒ¡ãƒ¼ãƒˆãƒ«å¤‰æ›
                    
                    // ã‚‚ã†ä¸€æ–¹ã‚‚æ¢ç´¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if (splitDistance < bestDistance || bestDistance > maxDistance) {
                        search(secondary, depth + 1);
                    }
                };
                
                search(this.root);
                return best;
            }
            
            // 2ç‚¹é–“ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ³å…¬å¼ï¼‰
            calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // åœ°çƒã®åŠå¾„ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
                const Ï†1 = lat1 * Math.PI / 180;
                const Ï†2 = lat2 * Math.PI / 180;
                const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
                const Î”Î» = (lon2 - lon1) * Math.PI / 180;
                
                const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                         Math.cos(Ï†1) * Math.cos(Ï†2) *
                         Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c;
            }
        }
        
        // åœ°å›³ã‚’åˆæœŸåŒ–
        function initMap() {
            map = L.map('map').setView([36.2048, 138.2529], 6); // æ—¥æœ¬ä¸­å¤®éƒ¨
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            
            // åœ°å›³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            map.on('click', onMapClick);
            
            // åœ°å›³ç§»å‹•æ™‚ã«ä½ç½®è¿½å¾“ã‚’ç„¡åŠ¹åŒ–
            map.on('dragstart', function() {
                if (followingLocation) {
                    followingLocation = false;
                    console.log('æ‰‹å‹•ç§»å‹•ã«ã‚ˆã‚Šä½ç½®è¿½å¾“ã‚’ä¸€æ™‚åœæ­¢');
                }
            });
        }
        
        // CSVãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        async function loadAddressData() {
            try {
                document.getElementById('progress').textContent = 'CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...';
                
                const response = await fetch('merged.csv');
                const csvText = await response.text();
                
                document.getElementById('progress').textContent = 'CSVãƒ‡ãƒ¼ã‚¿ã‚’è§£æä¸­...';
                await new Promise(resolve => setTimeout(resolve, 10)); // UIæ›´æ–°ã®ãŸã‚ã®çŸ­ã„å¾…æ©Ÿ
                
                parseCSV(csvText);
                
                document.getElementById('progress').textContent = 'kdæœ¨ã‚’æ§‹ç¯‰ä¸­...';
                await new Promise(resolve => setTimeout(resolve, 10)); // UIæ›´æ–°ã®ãŸã‚ã®çŸ­ã„å¾…æ©Ÿ
                
                buildKDTree();
                
                document.getElementById('loading').style.display = 'none';
                
                // ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤ºï¼ˆä½ç½®è¿½å¾“ã¯åˆæœŸçŠ¶æ…‹ã§OFFï¼‰
                const locationPanel = document.getElementById('locationPanel');
                locationPanel.style.display = 'block';
                
                const performancePanel = document.getElementById('performance');
                performancePanel.style.display = 'block';
                
                // åˆæœŸçŠ¶æ…‹ã§ã¯ä½ç½®è¿½å¾“ã‚’OFFã«è¨­å®š
                document.getElementById('locationContent').innerHTML = 
                    '<div class="location-status">ä½ç½®è¿½å¾“ã‚’ONã«ã™ã‚‹ã¨ç¾åœ¨ä½ç½®ã‚’è¡¨ç¤ºã—ã¾ã™</div>';
                
            } catch (error) {
                console.error('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                document.getElementById('loading').innerHTML = 
                    '<div style="color: red;">CSVãƒ•ã‚¡ã‚¤ãƒ«ã€Œmerged.csvã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“<br>åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«é…ç½®ã—ã¦ãã ã•ã„</div>';
            }
        }
        
        // CSVã‚’è§£æ
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            
            // ãƒ˜ãƒƒãƒ€ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
            const lgCodeIndex = headers.indexOf('lg_code');
            const machiazeIdIndex = headers.indexOf('machiaza_id');
            const latIndex = headers.indexOf('rep_lat');
            const lonIndex = headers.indexOf('rep_lon');
            const prefIndex = headers.indexOf('pref');
            const prefKanaIndex = headers.indexOf('pref_kana');
            const cityIndex = headers.indexOf('city');
            const cityKanaIndex = headers.indexOf('city_kana');
            const wardIndex = headers.indexOf('ward');
            const wardKanaIndex = headers.indexOf('ward_kana');
            const oazaChoIndex = headers.indexOf('oaza_cho');
            const oazaChoKanaIndex = headers.indexOf('oaza_cho_kana');
            const chomeIndex = headers.indexOf('chome');
            const chomeKanaIndex = headers.indexOf('chome_kana');
            const koazaIndex = headers.indexOf('koaza');
            const koazaKanaIndex = headers.indexOf('koaza_kana');
            
            addressData = [];
            
            // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’è§£æ
            for (let i = 1; i < lines.length; i++) {
                const columns = lines[i].split(',');
                
                if (columns.length > 0) {
                    const lat = parseFloat(columns[latIndex]);
                    const lon = parseFloat(columns[lonIndex]);
                    
                    if (!isNaN(lat) && !isNaN(lon)) {
                        const record = {
                            lg_code: columns[lgCodeIndex] || '',
                            machiaza_id: columns[machiazeIdIndex] || '',
                            lat: lat,
                            lon: lon,
                            pref: columns[prefIndex] || '',
                            pref_kana: columns[prefKanaIndex] || '',
                            city: columns[cityIndex] || '',
                            city_kana: columns[cityKanaIndex] || '',
                            ward: columns[wardIndex] || '',
                            ward_kana: columns[wardKanaIndex] || '',
                            oaza_cho: columns[oazaChoIndex] || '',
                            oaza_cho_kana: columns[oazaChoKanaIndex] || '',
                            chome: columns[chomeIndex] || '',
                            chome_kana: columns[chomeKanaIndex] || '',
                            koaza: columns[koazaIndex] || '',
                            koaza_kana: koazaKanaIndex < columns.length ? columns[koazaKanaIndex] || '' : ''
                        };
                        
                        addressData.push(record);
                    }
                }
            }
            
            console.log(`ä½æ‰€ãƒ‡ãƒ¼ã‚¿ ${addressData.length.toLocaleString()} ä»¶ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
            document.getElementById('dataCount').textContent = addressData.length.toLocaleString();
        }
        
        // kdæœ¨ã‚’æ§‹ç¯‰
        function buildKDTree() {
            const startTime = performance.now();
            
            kdTree = new KDTree(addressData);
            
            const endTime = performance.now();
            const buildTime = Math.round(endTime - startTime);
            
            console.log(`kdæœ¨æ§‹ç¯‰å®Œäº†: ${buildTime}ms`);
            document.getElementById('buildTime').textContent = buildTime;
        }
        
        // ä½æ‰€æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
        function buildAddressString(record) {
            let address = record.pref;
            if (record.city) address += record.city;
            if (record.ward) address += record.ward;
            if (record.oaza_cho) address += record.oaza_cho;
            if (record.chome) address += record.chome;
            if (record.koaza) address += record.koaza;
            return address;
        }
        
        // ã‚«ãƒŠä½æ‰€æ–‡å­—åˆ—ã‚’æ§‹ç¯‰
        function buildAddressKanaString(record) {
            let kana = record.pref_kana || '';
            if (record.city_kana) kana += record.city_kana;
            if (record.ward_kana) kana += record.ward_kana;
            if (record.oaza_cho_kana) kana += record.oaza_cho_kana;
            if (record.chome_kana) kana += record.chome_kana;
            if (record.koaza_kana) kana += record.koaza_kana;
            
            return kana;
        }
        
        // ä½ç½®ã®äºˆæ¸¬ã‚’è¨ˆç®—
        function predictPosition() {
            if (locationHistory.length < 2) return null;
            
            const now = Date.now();
            const timeSinceLastUpdate = now - lastUpdateTime;
            
            // æœ€å¤§äºˆæ¸¬æ™‚é–“ã‚’è¶…ãˆãŸå ´åˆã¯äºˆæ¸¬ã‚’åœæ­¢
            if (timeSinceLastUpdate > MAX_PREDICTION_TIME) {
                return null;
            }
            
            // ç›´è¿‘ã®2ç‚¹ã‹ã‚‰é€Ÿåº¦ã‚’è¨ˆç®—
            const recent = locationHistory.slice(-2);
            const timeDiff = recent[1].timestamp - recent[0].timestamp;
            
            if (timeDiff <= 0) return null;
            
            const latDiff = recent[1].lat - recent[0].lat;
            const lonDiff = recent[1].lon - recent[0].lon;
            
            // ç§»å‹•è·é›¢ã‚’è¨ˆç®—
            const distance = kdTree.calculateDistance(recent[0].lat, recent[0].lon, recent[1].lat, recent[1].lon);
            const speed = distance / (timeDiff / 1000); // m/s
            
            // ç§»å‹•é€Ÿåº¦ãŒé–¾å€¤ä»¥ä¸‹ã®å ´åˆã§ã‚‚äºˆæ¸¬ä½ç½®ã¯è¨ˆç®—ï¼ˆè¡¨ç¤ºæ›´æ–°ã®åˆ¤å®šã¯åˆ¥ã§è¡Œã†ï¼‰
            
            // æ™‚é–“ã‚ãŸã‚Šã®å¤‰åŒ–ç‡ã‚’è¨ˆç®—
            const latRate = latDiff / timeDiff; // åº¦/ms
            const lonRate = lonDiff / timeDiff; // åº¦/ms
            
            // ç¾åœ¨æ™‚åˆ»ã§ã®äºˆæ¸¬ä½ç½®ã‚’è¨ˆç®—
            const predictedLat = recent[1].lat + latRate * timeSinceLastUpdate;
            const predictedLon = recent[1].lon + lonRate * timeSinceLastUpdate;
            
            return {
                lat: predictedLat,
                lon: predictedLon,
                speed: speed,
                timeSinceUpdate: timeSinceLastUpdate
            };
        }
        
        // äºˆæ¸¬ä½ç½®ã®æ›´æ–°
        function updatePredictedLocation() {
            if (!predictionEnabled || !locationTracking) return;
            
            const predicted = predictPosition();
            if (predicted) {
                currentPredictedPosition = predicted;
                
                // ä½ç½®è¿½å¾“ä¸­ã¯åœ°å›³ã®ä¸­å¿ƒã‚’äºˆæ¸¬ä½ç½®ã«ç§»å‹•
                if (followingLocation) {
                    map.setView([predicted.lat, predicted.lon], map.getZoom(), { animate: false });
                }
                
                // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°
                updateLocationMarker(predicted.lat, predicted.lon, true);
                
                // ç§»å‹•é€Ÿåº¦ãŒä¸€å®šä»¥ä¸Šã®å ´åˆã®ã¿ä½æ‰€è¡¨ç¤ºã‚’æ›´æ–°ï¼ˆã¡ã‚‰ã¤ãé˜²æ­¢ï¼‰
                if (predicted.speed > 1.0) { // 1.0m/sä»¥ä¸Šã§ç§»å‹•ä¸­ã®å ´åˆã®ã¿æ›´æ–°
                    updateAddressDisplay(predicted.lat, predicted.lon, true, predicted);
                } else {
                    // åœæ­¢ä¸­ã¯åº§æ¨™æƒ…å ±ã®ã¿ã‚’æ›´æ–°
                    updateCoordinatesOnly(predicted.lat, predicted.lon, true, predicted);
                }
            }
        }
        
        // äºˆæ¸¬æ©Ÿèƒ½ã®é–‹å§‹
        function startPrediction() {
            predictionEnabled = true;
            document.getElementById('predictionToggle').textContent = 'äºˆæ¸¬ ON';
            document.getElementById('predictionToggle').classList.remove('disabled');
            document.getElementById('predictionRate').textContent = (1000 / PREDICTION_UPDATE_INTERVAL).toFixed(1);
            
            predictionTimer = setInterval(updatePredictedLocation, PREDICTION_UPDATE_INTERVAL);
            console.log('ä½ç½®äºˆæ¸¬æ©Ÿèƒ½ã‚’é–‹å§‹ã—ã¾ã—ãŸ');
        }
        
        // äºˆæ¸¬æ©Ÿèƒ½ã®åœæ­¢
        function stopPrediction() {
            predictionEnabled = false;
            document.getElementById('predictionToggle').textContent = 'äºˆæ¸¬ OFF';
            document.getElementById('predictionToggle').classList.add('disabled');
            document.getElementById('predictionRate').textContent = '-';
            
            if (predictionTimer) {
                clearInterval(predictionTimer);
                predictionTimer = null;
            }
            
            currentPredictedPosition = null;
            console.log('ä½ç½®äºˆæ¸¬æ©Ÿèƒ½ã‚’åœæ­¢ã—ã¾ã—ãŸ');
        }
        
        // äºˆæ¸¬æ©Ÿèƒ½ã®åˆ‡ã‚Šæ›¿ãˆ
        function togglePrediction() {
            if (predictionEnabled) {
                stopPrediction();
            } else {
                startPrediction();
            }
        }
        
        // ä½ç½®è¿½å¾“é–‹å§‹
        function startLocationTracking() {
            if (!navigator.geolocation) {
                document.getElementById('locationContent').innerHTML = 
                    '<div class="location-error">ä½ç½®æƒ…å ±ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“</div>';
                return;
            }
            
            locationTracking = true;
            followingLocation = true;
            const toggleBtn = document.getElementById('locationToggle');
            toggleBtn.textContent = 'ä½ç½®è¿½å¾“ ON';
            toggleBtn.classList.remove('disabled');
            
            // å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
            locationHistory = [];
            lastKnownPosition = null;
            lastUpdateTime = null;
            currentPredictedPosition = null;
            
            // iOSã§ã‚ˆã‚Šè‰¯ã„ä½ç½®ç²¾åº¦ã‚’å¾—ã‚‹ãŸã‚ã®è¨­å®š
            const options = {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 10000 // 10ç§’é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
            };
            
            document.getElementById('locationContent').innerHTML = 
                '<div class="location-status">ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­...</div>';
            
            // åˆå›ä½ç½®å–å¾—
            navigator.geolocation.getCurrentPosition(
                updateCurrentLocation,
                handleLocationError,
                options
            );
            
            // ä½ç½®ã®ç›£è¦–ã‚’é–‹å§‹
            watchId = navigator.geolocation.watchPosition(
                updateCurrentLocation,
                handleLocationError,
                options
            );
        }
        
        // æƒ…å ±ãƒ‘ãƒãƒ«ã®æŠ˜ã‚ŠãŸãŸã¿åˆ‡ã‚Šæ›¿ãˆ
        function toggleInfoPanel() {
            const panel = document.getElementById('infoPanel');
            const button = panel.querySelector('.collapse-toggle');
            const isCollapsed = panel.classList.contains('collapsed');
            
            if (isCollapsed) {
                panel.classList.remove('collapsed');
                button.textContent = 'âˆ’';
                button.title = 'ãƒ‘ãƒãƒ«ã‚’æŠ˜ã‚ŠãŸãŸã‚€';
                document.body.classList.remove('info-collapsed');
            } else {
                panel.classList.add('collapsed');
                button.textContent = '+';
                button.title = 'ãƒ‘ãƒãƒ«ã‚’å±•é–‹ã™ã‚‹';
                document.body.classList.add('info-collapsed');
            }
        }
        
        // ä½ç½®è¿½å¾“åœæ­¢
        function stopLocationTracking() {
            locationTracking = false;
            followingLocation = false;
            document.getElementById('locationToggle').textContent = 'ä½ç½®è¿½å¾“ OFF';
            document.getElementById('locationToggle').classList.add('disabled');
            
            // äºˆæ¸¬æ©Ÿèƒ½ã‚‚åœæ­¢
            stopPrediction();
            
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            if (currentLocationMarker) {
                map.removeLayer(currentLocationMarker);
                currentLocationMarker = null;
            }
            
            // å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
            locationHistory = [];
            lastKnownPosition = null;
            lastUpdateTime = null;
            currentPredictedPosition = null;
            
            document.getElementById('locationContent').innerHTML = 
                '<div class="location-status">ä½ç½®è¿½å¾“ãŒåœæ­¢ã•ã‚Œã¦ã„ã¾ã™</div>';
        }
        
        // ä½ç½®è¿½å¾“ã®ã‚ªãƒ³/ã‚ªãƒ•åˆ‡ã‚Šæ›¿ãˆ
        function toggleLocationTracking() {
            if (locationTracking) {
                stopLocationTracking();
            } else {
                startLocationTracking();
            }
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼ã®æ›´æ–°
        function updateLocationMarker(lat, lng, isPredicted = false) {
            if (currentLocationMarker) {
                map.removeLayer(currentLocationMarker);
            }
            
            const iconUrl = isPredicted ? 
                'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-violet.png' :
                'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png';
            
            currentLocationMarker = L.marker([lat, lng], {
                icon: L.icon({
                    iconUrl: iconUrl,
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
        }
        
        // äºˆæ¸¬ãƒ¢ãƒ¼ãƒ‰æ™‚ã®GPSæ›´æ–°ç”¨ä½æ‰€è¡¨ç¤º
        function updateAddressDisplayWithPredictionMode(lat, lng, accuracy) {
            if (!kdTree) return;
            
            const startTime = performance.now();
            const nearest = kdTree.findNearest(lat, lng);
            const endTime = performance.now();
            const searchTime = Math.round((endTime - startTime) * 1000) / 1000;
            
            document.getElementById('searchTime').textContent = searchTime;
            
            if (nearest) {
                const address = buildAddressString(nearest);
                const kana = buildAddressKanaString(nearest);
                
                let content = `
                    <div class="current-address">
                        <div class="address">${address}</div>
                        <div class="kana">${kana}</div>
                        <div class="coords">
                            äºˆæ¸¬ä½ç½®: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                            ä½æ‰€åœ°ç‚¹: ${nearest.lat.toFixed(6)}, ${nearest.lon.toFixed(6)}<br>
                            è·é›¢: ${nearest.distance.toFixed(0)}m<br>
                            GPSç²¾åº¦: ${accuracy.toFixed(0)}m
                        </div>
                        <div class="prediction-info">ğŸ”® äºˆæ¸¬ã«ã‚ˆã‚‹ä½ç½®è¡¨ç¤º</div>
                    </div>
                `;
                
                document.getElementById('locationContent').innerHTML = content;
            } else {
                document.getElementById('locationContent').innerHTML = 
                    '<div class="location-status">äºˆæ¸¬ä½ç½®ã®è¿‘ãã«ä½æ‰€ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
            }
        }
        
        // åº§æ¨™æƒ…å ±ã®ã¿ã‚’æ›´æ–°ï¼ˆä½æ‰€æ¤œç´¢ãªã—ï¼‰
        function updateCoordinatesOnly(lat, lng, isPredicted = false, predictionInfo = null) {
            // æ—¢å­˜ã®ä½æ‰€æƒ…å ±ã‚’ä¿æŒã—ãŸã¾ã¾åº§æ¨™éƒ¨åˆ†ã®ã¿ã‚’æ›´æ–°
            const locationContent = document.getElementById('locationContent');
            const addressDiv = locationContent.querySelector('.current-address');
            
            if (addressDiv) {
                const coordsDiv = addressDiv.querySelector('.coords');
                if (coordsDiv) {
                    let coordsText = `
                        ${isPredicted ? 'äºˆæ¸¬ä½ç½®' : 'ç¾åœ¨ä½ç½®'}: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                    `;
                    
                    // æ—¢å­˜ã®ä½æ‰€åœ°ç‚¹æƒ…å ±ã‚’ä¿æŒ
                    const existingText = coordsDiv.innerHTML;
                    const addressPointMatch = existingText.match(/ä½æ‰€åœ°ç‚¹: ([^<]+)<br>/);
                    const distanceMatch = existingText.match(/è·é›¢: ([^<]+)<br>/);
                    
                    if (addressPointMatch && distanceMatch) {
                        coordsText += `ä½æ‰€åœ°ç‚¹: ${addressPointMatch[1]}<br>`;
                        coordsText += `è·é›¢: ${distanceMatch[1]}<br>`;
                    }
                    
                    if (isPredicted && predictionInfo) {
                        coordsText += `ç§»å‹•é€Ÿåº¦: ${predictionInfo.speed.toFixed(1)}m/s`;
                        // coordsText += `æ›´æ–°ã‹ã‚‰: ${(predictionInfo.timeSinceUpdate / 1000).toFixed(1)}ç§’`;
                    }
                    
                    coordsDiv.innerHTML = coordsText;
                }
                
                // äºˆæ¸¬è¡¨ç¤ºã®æ›´æ–°
                let predictionDiv = addressDiv.querySelector('.prediction-info');
                if (isPredicted) {
                    if (!predictionDiv) {
                        predictionDiv = document.createElement('div');
                        predictionDiv.className = 'prediction-info';
                        addressDiv.appendChild(predictionDiv);
                    }
                    predictionDiv.textContent = 'ğŸ”® äºˆæ¸¬ã«ã‚ˆã‚‹ä½ç½®è¡¨ç¤º';
                } else if (predictionDiv) {
                    predictionDiv.remove();
                }
            }
        }
        
        // ä½æ‰€è¡¨ç¤ºã®æ›´æ–°
        function updateAddressDisplay(lat, lng, isPredicted = false, predictionInfo = null) {
            if (!kdTree) return;
            
            const startTime = performance.now();
            const nearest = kdTree.findNearest(lat, lng);
            const endTime = performance.now();
            const searchTime = Math.round((endTime - startTime) * 1000) / 1000;
            
            document.getElementById('searchTime').textContent = searchTime;
            
            if (nearest) {
                const address = buildAddressString(nearest);
                const kana = buildAddressKanaString(nearest);
                
                let content = `
                    <div class="current-address">
                        <div class="address">${address}</div>
                        <div class="kana">${kana}</div>
                        <div class="coords">
                            ${isPredicted ? 'äºˆæ¸¬ä½ç½®' : 'ç¾åœ¨ä½ç½®'}: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                            ä½æ‰€åœ°ç‚¹: ${nearest.lat.toFixed(6)}, ${nearest.lon.toFixed(6)}<br>
                            è·é›¢: ${nearest.distance.toFixed(0)}m
                `;
                
                if (isPredicted && predictionInfo) {
                    content += `<br>ç§»å‹•é€Ÿåº¦: ${predictionInfo.speed.toFixed(1)}m/s`;
                    content += `<br>æ›´æ–°ã‹ã‚‰: ${(predictionInfo.timeSinceUpdate / 1000).toFixed(1)}ç§’`;
                }
                
                content += `
                        </div>
                `;
                
                if (isPredicted) {
                    content += `<div class="prediction-info">ğŸ”® äºˆæ¸¬ã«ã‚ˆã‚‹ä½ç½®è¡¨ç¤º</div>`;
                }
                
                content += `</div>`;
                
                document.getElementById('locationContent').innerHTML = content;
            } else {
                const statusText = isPredicted ? 'äºˆæ¸¬ä½ç½®ã®è¿‘ãã«ä½æ‰€ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' : 'è¿‘ãã«ä½æ‰€ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                document.getElementById('locationContent').innerHTML = 
                    `<div class="location-status">${statusText}</div>`;
            }
        }
        
        // ç¾åœ¨ä½ç½®ã‚’æ›´æ–°
        function updateCurrentLocation(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const timestamp = Date.now();
            
            console.log('ç¾åœ¨ä½ç½®:', lat, lng, 'ç²¾åº¦:', accuracy + 'm');
            
            // å±¥æ­´ã«è¿½åŠ 
            const locationPoint = { lat, lon: lng, timestamp, accuracy };
            locationHistory.push(locationPoint);
            
            // å±¥æ­´ã‚µã‚¤ã‚ºã‚’åˆ¶é™
            if (locationHistory.length > PREDICTION_HISTORY_SIZE) {
                locationHistory.shift();
            }
            
            lastKnownPosition = locationPoint;
            lastUpdateTime = timestamp;
            
            // ä½ç½®è¿½å¾“ä¸­ã¯åœ°å›³ã®ä¸­å¿ƒã‚’ç¾åœ¨ä½ç½®ã«ç§»å‹•
            if (followingLocation) {
                map.setView([lat, lng], map.getZoom(), { animate: true });
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ›´æ–°ï¼ˆå®Ÿéš›ã®ä½ç½®ãªã®ã§äºˆæ¸¬ãƒ•ãƒ©ã‚°ã¯falseï¼‰
            updateLocationMarker(lat, lng, false);
            
            // äºˆæ¸¬æ©Ÿèƒ½ãŒONã®å ´åˆã¯äºˆæ¸¬è¡¨ç¤ºã‚’ç¶­æŒã€OFFã®å ´åˆã®ã¿é€šå¸¸è¡¨ç¤º
            if (predictionEnabled) {
                // äºˆæ¸¬æ©Ÿèƒ½ONæ™‚ã¯ä½æ‰€æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹ãŒäºˆæ¸¬è¡¨ç¤ºã¯ç¶­æŒ
                updateAddressDisplayWithPredictionMode(lat, lng, accuracy);
            } else {
                // äºˆæ¸¬æ©Ÿèƒ½OFFæ™‚ã¯é€šå¸¸ã®è¡¨ç¤º
                updateAddressDisplay(lat, lng, false);
            }
        }
        
        // ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼å‡¦ç†
        function handleLocationError(error) {
            let errorMessage = '';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage = 'ä½ç½®æƒ…å ±ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ';
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage = 'ä½ç½®æƒ…å ±ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“';
                    break;
                case error.TIMEOUT:
                    errorMessage = 'ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ';
                    break;
                default:
                    errorMessage = 'ä½ç½®æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
                    break;
            }
            
            console.error('ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼:', error);
            document.getElementById('locationContent').innerHTML = 
                `<div class="location-error">${errorMessage}</div>`;
        }
        
        // åœ°å›³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
        function onMapClick(e) {
            const clickLat = e.latlng.lat;
            const clickLon = e.latlng.lng;
            
            // kdæœ¨ã‚’ä½¿ç”¨ã—ãŸé«˜é€Ÿæ¤œç´¢
            const startTime = performance.now();
            const nearest = kdTree.findNearest(clickLat, clickLon);
            const endTime = performance.now();
            const searchTime = Math.round((endTime - startTime) * 1000) / 1000; // å°æ•°ç‚¹3æ¡
            
            document.getElementById('searchTime').textContent = searchTime;
            console.log(`æ¤œç´¢æ™‚é–“: ${searchTime}ms`);
            
            if (nearest) {
                const address = buildAddressString(nearest);
                const kana = buildAddressKanaString(nearest);
                
                const popupContent = `
                    <div class="popup-content">
                        <div class="address">${address}</div>
                        <div class="kana">${kana}</div>
                        <div class="coords">
                            ã‚¯ãƒªãƒƒã‚¯åœ°ç‚¹: ${clickLat.toFixed(6)}, ${clickLon.toFixed(6)}<br>
                            ä½æ‰€åœ°ç‚¹: ${nearest.lat.toFixed(6)}, ${nearest.lon.toFixed(6)}<br>
                            è·é›¢: ${nearest.distance.toFixed(0)}m<br>
                            æ¤œç´¢æ™‚é–“: ${searchTime}ms
                        </div>
                    </div>
                `;
                
                L.popup()
                    .setLatLng(e.latlng)
                    .setContent(popupContent)
                    .openOn(map);
                
                // ä½æ‰€ã®å®Ÿéš›ã®ä½ç½®ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¸€æ™‚çš„ã«è¡¨ç¤º
                const marker = L.marker([nearest.lat, nearest.lon], {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    })
                }).addTo(map);
                
                // 3ç§’å¾Œã«ãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
                setTimeout(() => {
                    map.removeLayer(marker);
                }, 3000);
                
            } else {
                L.popup()
                    .setLatLng(e.latlng)
                    .setContent(`<div class="popup-content">ã“ã®åœ°ç‚¹ã®è¿‘ãã«ä½æ‰€ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ<br>æ¤œç´¢æ™‚é–“: ${searchTime}ms</div>`)
                    .openOn(map);
            }
        }
        
        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            loadAddressData();
        });
    </script>
</body>
</html>